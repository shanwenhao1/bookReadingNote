# 协程

## 线程池的缺陷

  在高并发应用中为了避免频繁创建线程造成不必要的开销, 常常使用线程池从任务队列中取出任务并执行的方式来处理并发.
但线程池中执行任务的线程一旦发生系统调用, 会导致该线程阻塞, 从而降低线程池对任务队列的消费能力. 影响性能.

## Goroutine调度器

Go提供了一种机制, 该机制在线程中自己实现调度, 上下文切换更轻量. 线程中调度的就是Goroutine


Goroutine主要概念如下:
* G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程
* M（Machine）：工作线程，在Go中称为Machine
    - 一般情况下M的个数会略大于P的个数，这多出来的M将会在G产生系统调用时发挥作用
* P(Processor):	处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力
    - M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行
    - P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，
    也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销
    - `runtime.GOMAXPROCS()` 设置P的个数


![](picture/syscall.jpg)
Go并发高效的原因:
* 如图所示，当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。
而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU
    - M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理
        - 如果有空闲的P，则获取一个P，继续执行G0
        - 如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠
* 工作量窃取: 已执行完成G的P会查询全局队列中是否还有G, 如果没有, 则会窃取其他M中等待执行的G的队列(一般窃取一半)过来
执行.