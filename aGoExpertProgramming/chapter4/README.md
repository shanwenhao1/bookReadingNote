# 内存管理

## 内存分配原理

### span: 内存管理基本单位

span是内存管理的基本单位,每个span用于管理特定的class对象, 跟据对象大小，span将一个或多个页拆分成多个块进行管理

```go
type	mspan	struct	{
	next                *mspan				//链表后向指针，用于将span链接起来
	prev	            *mspan				//链表前向指针，用于将span链接起来
	startAddr	        uintptr	            //	起始地址，也即所管理页的地址
	npages				uintptr	            //	管理的页数

	nelems	            uintptr	            //	块个数，也即有多少个块可供分配

	allocBits		    *gcBits	            //分配位图，每一位代表一个块是否已分配
                                            //  gcmarkBits是span中的另外一个位图, 其用于记录内存标记情况,
                                            //  有对象引用为1, 否则为0. 用于gc

	allocCount		    uint16				//	已分配块的个数
	spanclass			spanClass		    //	class表中的class	ID
	elemsize			uintptr				//	class表中的对象大小，也即块大小 
}
```


mcentral数据结构用来管理span. 各线程需要内存时从mcentral管理的span中申请内
* 为了避免多线程申请内存时不断的加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache
```go
// cache数据结构
type	mcache	struct	{
  alloc       [67*2]*mspan	//	按class分组的mspan列表, 大小为class总数的两倍.
                            //      每种class类型都有两组span列表，第一组列表中所表示的对象中包含了指针，第二组列表中所表示的对象不含
                            //      有指针(这么做是为了提高GC扫描性能，对于不包含指针的span列表，没必要去扫描)
}
```
    - 根据对象是否包含指针，将对象分为noscan和scan两类：
        - 其中noscan代表没有指针
        - scan则代表有指针，需要GC进行扫描
        

#### central
central则是全局资源，为多个线程服务： 当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central


### 总结
* Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域
* arena区域按页划分成一个个小块
* span管理一个或多个页
* mcentral管理多个span供线程申请使用
* mcache作为线程私有资源，资源来源于mcentral


## 垃圾回收原理

### 垃圾回收算法
业界常见的垃圾回收算法:
* 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象
    - 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收
    - 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价
    - 代表语言：Python、PHP、Swift
* 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收
    - 优点：解决了引用计数的缺点
    - 缺点：需要STW，即要暂时停掉程序运行
    - 代表语言：Golang(其采用三色标记法)
* 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率
    - 优点：回收性能好
    - 缺点：算法复杂
    - 代表语言：JAVA
    
### Golang垃圾回收
Golang垃圾回收的核心就是标记出哪些内存还在使用中(即被引用到)，哪些内存不再使用了（即未被引用），把未被引用的内存回收掉，
以供后续内存分配时使用

golang三色标记法指的是gc中的三种状态:
* 灰色：对象还在标记队列中等待
* 黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
* 白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）


#### 垃圾回收优化
* 写屏障: 写屏障就是让goroutine与GC同时运行的手段. 写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，
即本轮不回收，下次GC时再确定
* 辅助GC(Mutator	Assist): 为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，
即帮助GC做一部分工作，这个机制叫作Mutator	Assist

#### 垃圾回收触发时机
1. 每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动GC
*  `阀值	=	上次GC内存分配量	*	内存增长率`
    - 内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC
    
2. 定期触发GC(默认情况下，最长2分钟触发一次GC)

3. 手动触发


#### GC性能优化
对象越多GC性能越差，对程序影响越大. 所以GC性能优化的思路之一就是减少对象分配个数


## 逃逸分析

所谓逃逸分析（Escape	analysis）是指由编译器决定内存分配的位置，不需要程序员指定。函数中申请一个新的对象
* 如果分配在栈中，则函数执行结束可自动将内存回收
    - 如果函数外部没有引用，则优先放到栈中
    - 对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力
* 如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理
    - 如果函数外部存在引用，则必定放到堆中
    
### 逃逸场景
* 指针逃逸
```go
package	main

type Student struct	{
    Name    string
    Age		int
}

/*
    函数StudentRegister()内部s为局部变量，其值通过函数返回值返回，s本身为一指针，
    其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例
*/
func StudentRegister(name string, age int) *Student {
	s := new(Student) //局部变量s逃逸到堆
	s.Name = name
    s.Age = age
    return s
}

func main()	{
    StudentRegister("Jim", 18)
}
```
* 栈空间不足逃逸
* 动态类型逃逸: 例如fmt.Println(a	…interface{})，编译期间很难确定其参数的具体类型，也人产生逃逸
* 闭包引用对象逃逸

### 逃逸总结
* 栈上分配内存比在堆中分配内存有更高的效率
* 栈上分配的内存不需要GC处理
* 堆上分配的内存使用完毕会交给GC处理
* 逃逸分析目的是决定内分配地址是栈还是堆
* 逃逸分析在编译阶段完成
