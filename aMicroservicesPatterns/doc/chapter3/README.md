# 微服务架构中的进程通信

导读: 
- 通信模式的具体应用: 远程过程调用、断路器、客户端发现、自注册、服务端发现、第三方注册、 异步消息、
事务性发件箱、事务日志拖尾、轮询发布者
- 进程间通信(IPC)机制的重要性

一个理想的微服务架构应该是在内部由松散耦合的若干服务组成, 这些服务使用异步消息相互通信. REST
(主要使用JSON)等同步协议主要用于服务与外部其他应用程序的通信.

使用某种`接口定义语言(IDL)`精确定义服务的API很重要.

## 进程间通信

可分为:
- 基于同步请求/响应的通信机制: HTTP REST、 gRPC
    - 使用断路器处理局部故障: 本质上是一个远程调用的代理, 在连续失败次数超过指定阈值后的一段时间内, 这个
    代理会立即拒绝其他调用.
    - 开发可靠的远程过程调用代理, 需要做到如下的要求:
        - 网络超时: 在等待针对请求的响应时, 一定不要做成无限阻塞
        - 限制客户端向服务器发出请求的数量
        - 断路器模式: 监控客户端发出请求的成功和失败数量, 失败超过一定阈值, 就启动断路器, 让后续的调用失效. 
        经过一段时间后, 客户端应该继续尝试, 如果调用成功, 则接触断路器.
- 异步的基于消息的通信机制: AMQP、STOMP

交互方式按照模式可分为:
- 第一个维度: 
    - 一对一
    - 一对多
- 第二个维度
    - 同步模式
    - 异步模式
    
## API
变更API, 一般采用滚动升级的方式来更新服务, 因此一个服务的旧版本和新版本肯定会共存. 因此, 我们需要语义化版本控制

### 语义化版本控制

它是一种规则, 用于指定如何使用版本号, 并且以正确的方式递增版本号. 版本号由三部分组成: MAJOR.MINOR.PATCH
- MAJOR: 当你对API进行不兼容的更改时
- MINOR: 当你对API进行向后兼容的增强时
- PATCH: 当你进行向后兼容的错误修复时

理想情况下, 你应该努力只进行向后兼容的更改(是对API的附加更改或功能增强)
- 添加可选属性
- 向响应添加属性
- 添加新操作
    
### 消息格式
- 基于文本的消息格式: JSON和XML这样的基于文本的格式
    - 优点: 可读性高、自描述
    - 缺点: 消息过于冗长造成额外开销、解析消耗
- 二进制消息格式: Protocol Buffers、Avro等.  这两种都提供了一个强类型定义的IDL(接口描述文件, 
用于定义消息的格式, 编译器会自动根据这些格式序列化和反序列化代码)


### 通信
- 基于同步远程过程调用模式的通信: 如REST、gRPC
    - [gRPC](../../code/chapter3/grpcExample/README.md)
- 基于异步消息模式的通信:
    - [基于异步消息模式的通信](syncMsg.md)

### [断路器](../../../project/CircuitAndHystrix/README.md)

### [服务发现](Service-discovery.md)

## 相关

[gRPC Document](https://www.grpc.io/docs/)