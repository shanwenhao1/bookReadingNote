# 服务的拆分策略


## 软件架构

软件架构的4+1视图模型(是描述应用程序架构的绝佳方式)
- 四个视图: 每个视图描述了架构的一个重要侧面
    - 逻辑视图: 开发人员创建的软件元素
    - 实现视图: 构建编译系统的输出. 此视图由表示打包代码的模块和组件组成.
    - 进程视图: 运行时的组件, 每个元素都是一个进程, 进程之间的关系代表进程间通信
    - 部署视图: 进程如何映射到机器. 该视图还描述了进程和机器之间的关系.
- 一个场景： 负责将视图串联在一起. 每个场景负责描述在一个视图的多个架构元素如何协作, 以完成一个请求.

## 架构的风格

### 分层式架构风格
将软件元素按"层"的方式组织. 每个层都有明确定义的职责. 每一层只能依赖于紧邻其下方的层或其下面的任何层.

经典的三层架构:
- 表现层
- 业务逻辑

### 六边形架构风格
以逻辑为中心的方式组织逻辑视图


## 为应用程序定义微服务架构

一个大概定义方法:
- 第一步: 从需求开始, `定义系统操作`
- 第二步: 定义服务
- 第三步: 定义服务API和协作方式

两步式流程识别和定义操作系统(面向对象设计过程):
- 第一步创建由关键类组成的抽象领域模型, 这些关键类提供用于描述系统操作的词汇表
- 第二步确定系统操作, 并根据领域模型描述每个系统操作的行为

## 服务分解的障碍
- 网络延迟
    - 解决方法: 把多个相关的服务组合在一起, 用编程语言的函数调用替换昂贵的进程间通信
- 服务之间的同步通信降低了可用性
    - 解决方法: 不采用REST这种同步调用其他服务等待方式, 使用异步消息
- 跨服务的数据一致性
    - 解决方法:
        - 传统: 基于两阶段提交的分布式事务管理机制
        - 现今: Saga(一系列使用消息协作的本地事务)
- 上帝类(God Class), 一般为全局类, 可以使用领域驱动设计中的概念来消除上帝类.
    - 解决方法: 应用DDD并将每个服务视为具有自己的领域模型的单独子域

## 拆分的指导原则

定义类的职责时, 应该遵循单一职责原则(Single Responsibility Principle)
- 改变一个类应该只有一个理由

把类组成包时, 应该遵循闭包原则(Common Closure Principle, CCP)
- 在包中包含的所有类应该是对同类的变化的一个集合, 也就是说, 如果对包做出修改, 需要调整的类应该
都在这个包之内.

## 定义服务API
定义服务API的起点是将每个系统操作映射到服务. 之后确定服务是否需要与其他服务协作以实现系统
操作. 如果需要协作, 我们将确定其他服务必须提供哪些API才能支持协作.
- 把系统操作分配给服务
- 确定支持服务协作所需要的API

## 小结
- 架构决定了软件的各种非功能因素, 比如可维护性、可测试性、可部署性和可扩展性, 它们会直接影响开发速度.
- 微服务架构是一种架构风格, 它给应用程序带来了更高的可维护性、可测试性、可部署性和可扩展性
- 微服务中的服务是根据业务需求进行组织的, 按照业务能力或者子域, 而不是技术上的考量
- 有两种分解模式:
    - 按业务能力分解, 其起源于业务架构
    - 基于领域驱设计的概念, 通过子域进行分解
- 可以通过应用DDD并为每个服务定义单独的领域模型来消除上帝类, 正是上帝类引起了阻碍分解的交织依赖项